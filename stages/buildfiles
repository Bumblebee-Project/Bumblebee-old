#!/bin/bash
# This stage configures files so the resulting files can be used immediately by
# package managers
# Author: Lekensteyn <lekensteyn@gmail.com>

# Subject file for replacements by subst_var and def_var
CONFIGURING_FILE=

# Escapes \, & and , and newlines to prevent the sed expression from failing
sed_escape() {
    local data="$1"
    data="${data//\\/\\\\}"
    data="${data//&/\\&}"
    data="${data//,/\\,}"
    data="${data//
/\n}"
    echo "$data"
}

# copies a file (first argument) to the build directory (optionally rename it
# to the second argument) and set is as subject. Returns false if the source
# did not exist
set_file() {
    local file="$1"
    local target="$BUILDDIR/$file"
    [ -n "$2" ] && target="$BUILDDIR/$2"
    if [ -f "$file" ]; then
        # do not override old files, stages/builddir already takes care of
        # cleaning old files so we can be sure that existing files are
        # generated by the installer
        [ -f "$target" ] || install -D "$file" "$target"
        CONFIGURING_FILE="$target"
    else
        echo "'$file' not found, ignoring."
        CONFIGURING_FILE=
    fi
}

# Substitute a variable in the active file, the first argument is the variable
# name, the second the replacement. If omitted, the contents of the variable is
# used. It's assumed that the variable in the subject file is quoted and
# between curly brackets: echo "\$varname contains: ${varname}"
subst_var() {
    local varname="$1"
    local data="$2"
    # no replacement passed, assuming indirection of var
    if [ $# -eq 1 ]; then
        data="$(eval echo "\$$varname")"
    fi

    # Replace 'echo "${VAR}" by 'echo "value of \$VAR"'
    sreplace "\${${varname}}" '%s' "$data"
}

# Sets a variable definition in the active file
def_var() {
    local varname="$1"

    # quick-and-dirty fix to allow VAR[0]=VAL
    varname="${varname//[/\\[}"
    varname="${varname//]/\\]}"

    # escape single quote
    local data="${2//'/'\\''}"

    # Replace " VAR=WHAT" by " VAR='value of $data'"
    # sprintf and bash like to eat slashes, beware!
    sreplace "^\( *${varname}=\).*" "\\\\1'%s'" "$data"
}

# Replace a regex match with another string in the active file. The first arg
# is the search term, the second a sprintf formatted string which will not be
# escaped, third and up will be sed-escaped and sprintf'd in the second arg
sreplace() {
    # Return if there is no subject file
    [ -f "$CONFIGURING_FILE" ] || return

    local search="$1"
    local replacement="$2"
    local args=()
    while [ $# -gt 2 ]; do
        args[${#args[@]}]="$(sed_escape "$3")"
        shift
    done

    replacement="$(printf "$replacement" "${args[@]}")"

    sed "s,$search,$replacement,g" -i "$CONFIGURING_FILE"
}


set_file stages/configure
subst_var CONFDIR

set_file install-files/bumblebee.handler
def_var BIN "$SBINDIR/bumblebee"

set_file install-files/optirun
def_var BUMBLEBEE_LIBDIR "$LIBDIR"

set_file install-files/bumblebee
def_var BUMBLEBEE_LIBDIR "$LIBDIR"

set_file install-files/common-paths
def_var BUMBLEBEE_CONFDIR "$CONFDIR"
def_var 'OPTIRUNS[0]' "$BINDIR/optirun"

set_file install-files/common-functions
def_var BUMBLEBEE_VERSION "$BUMBLEBEE_VERSION"

set_file install-files/bumblebee.conf
def_var DRIVER "$DRIVER"

for driver in "${DRIVERS[@]}"; do
    # This change is only meaningful to the nvidia driver
    # XXX: make XORG_MODULEPATH driver-independent
    if [ "$driver" == "nvidia" ]; then
        set_file "install-files/xorg.conf.$driver"
        sreplace 'ModulePath  *"[^"]*"' 'ModulePath "%s"' "$XORG_MODULEPATH"
    fi
done
