#!/bin/bash
# Copyright (C) 2011 Bumblebee Project
#
# This file is part of Bumblebee.
#
# Bumblebee is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Bumblebee is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Bumblebee.  If not, see <http://www.gnu.org/licenses/>.

# Bumblebee functions library
# Make sure that this file has NO side effects. It is intended to be sourced
# and should define some functions and variables. Keep it clean, do not
# unnecessarily leak variables (use locals)

# Machine type, known values: i386, i686 (32-bit), x86_64 (64-bit)
# This value depends on the kernel
ARCH=$(uname -m)

# is the OS 32-bit or 64-bit? Save it to a variable since it's static.
IS_64=false
[[ $ARCH == x86_64 ]] && IS_64=true

# the modprobe binary
MODPROBE="$(which modprobe)"

# This version is set at installation time
BUMBLEBEE_VERSION=DEV

# The PCI Bus ID of the nvidia card, useful for lspci -s
NVIDIA_BUSID=$(lspci -d 10de: -n | grep '030[02]:' | cut -d' ' -f1)

# retrieve the graphics driver to be passed to rmmod
# Return values:
#   0: a valid driver is set, the driver is printed
#   1: an invalid driver is set, an error is printed to stderr
get_graphics_driver() {
    local driver
    # validate the driver setting
    for driver in nouveau nvidia; do
        if [[ $DRIVER == $driver ]] ; then
            echo $driver
            return 0
        fi
    done
    echo "Invalid driver set, valid ones are nvidia and nouveau" >&2
    return 1
}

# retrieve the graphics kernel module name based on a driver name (arg 1)
# Return values:
#   0: a module is available, the module name is printed
#   1: no module is available, an error is printed to stderr
get_graphics_module() {
    local driver="$1"
    if [ -n "$driver" ]; then
        # do not use modprobe since it fails if th edriver is already loaded
        if modinfo $driver &>/dev/null; then
            echo $driver
            return 0
        fi
        # ugly hack for Ubuntu on which the module nvidia-current.ko loads the
        # driver nvidia (as shown in /proc/modules). Alternative: set an alias
        # in /etc/modprobe.d/      alias nvidia nvidia-current
        if [[ $driver == nvidia ]] && modinfo nvidia-current &>/dev/null; then
            echo nvidia-current
            return 0
        fi
        echo "Driver '$driver' has no matching kernel module installed" >&2
    fi
    return 1
}

# Make sure that acpi_call is loaded when trying to use it.
# Returns 1 if it isn't.
load_acpi_call() {
    if ! lsmod | grep -q "acpi_call"; then
        "${MODPROBE}" "acpi_call" || return 1
    fi
    return 0
}

# Send a call to acpi_call and get the result
acpi_call() {
    load_acpi_call
    echo "$*" > /proc/acpi/call
    result=$(cat /proc/acpi/call)
    case "$result" in
      Error*)
        return 1
        ;;
      *)
        return 0
        ;;
    esac
}

# Check card status:
#  - return 0 if enabled
#  - return 1 is disabled
card_status() {
    if lspci -v -d 10de: | grep -q !; then
        return 1
    fi
    return 0
}

# Read the /etc/bumblebee/cardo{n,ff} and send
# the content line by line to acpi_call
enable_card() {
    if card_status; then
        while read call; do
            acpi_call "$call";
        done < /etc/bumblebee/cardon
        if card_status; then
            return 1
        fi
    fi
    return 0
}

disable_card() {
    if ! card_status; then
        while read call; do
            acpi_call "$call";
        done < /etc/bumblebee/cardoff
        if ! card_status; then
            return 1
        fi
    fi
    return 0
}

# load the driver, return 1 on failure
load_graphics_driver() {
    local driver module loaded_driver loaded_module
    # if there is an invalid driver setting, bail out. Ex: nvidia
    driver="$(get_graphics_driver)" || return 1
    # if there is no kernel module available, bail out. Ex: nvidia-current
    module="$(get_graphics_module "$driver")" || return 1

    # Get loaded video drivers for the device. nvidia under Ubuntu is a weird
    # case, Driver: nvidia, but Module: nvidia-current
    loaded_driver=$(lspci -s "$NVIDIA_BUSID" -vmk |
        grep '^Driver:' | cut -d: -f2)

    # unload a conflicting driver if any, do not return immediately on failure
    if [[ "$loaded_driver" != "$driver" ]]; then
        # Ex: loaded_module=nvidia-current for loaded_driver=nvidia
        loaded_module="$(get_graphics_module "$loaded_driver")"
        # modprobe can only handle cases where driver == module
        if [[ "$loaded_module" == "$loaded_driver" ]]; then
            modprobe -r "$loaded_module"
        else
            rmmod "$loaded_driver"
        fi
    fi

    # Load the video driver. Ex: nvidia-current
    modprobe "$module" || return 1
    return 0
}
# unload the driver, return 1 on failure. If the driver was already loaded, no
# action is performed
unload_graphics_driver() {
    local driver module
    # if there is an invalid driver setting, bail out. Ex: nvidia
    driver="$(get_graphics_driver)" || return 1
    # if there is no kernel module available, bail out. Ex: nvidia-current
    module="$(get_graphics_module "$driver")" || return 1

    # modprobe can only handle cases where driver == module
    if [[ "$module" == "$driver" ]]; then
        modprobe -r "$module" || return 1
    else
        rmmod "$driver" || return 1
    fi
    return 0
}

# Check if the X server is available based on a pidfile, daemon and args.
# If available, the PID of Bumblebee's X server is printed and the return value
# is 0. Other values indicates that the Bumblebee X server is not available:
# 1 - the X server has not been started
# 2 - the pidfile exists, but is not valid and should be removed
# 3 - Xorg was previously crashed by nvidia, reboot required
# 4 - a X server has been detected, but it's not Bumblebee's one
# 5 - X has started but cannot accept connections (yet)
xserver_available() {
    local pidfile x_daemon x_daemon_args pid cmd
    pidfile="$1"
    x_daemon="$2"
    x_daemon_args="$3"
    if [ ! -L "$pidfile" -a ! -e "$pidfile" ]; then
        # the pidfile does not exist
        return 1
    fi
    if [ -L "$pidfile" -o ! -f "$pidfile" ] ||
        ! [ "$(stat -c '%u' "$pidfile")" = "0" ]; then
        # the pidfile is a symlink, not a regular file or not owned by root
        return 2
    fi
    # read the first line from the pidfile, ignoring whitespace
    read pid < "$pidfile"
    if [ -z "$pid" ] ||
        ! [ "$pid" -gt 0 -o "$pid" -le 0 ] 2>/dev/null; then
        # empty pidfile or non-numeric pid (non-numeric values never fulfil
        # n > 0 && n <= 0)
        return 2
    fi
    if ! ps --pid "$pid" &>/dev/null; then
        # process does not exist
        return 2
    fi

    cmd="$(ps --format command --no-headers -ww --pid $pid)"

    if [[ $cmd == '[Xorg]' ]]; then
        # crashed xorg and / or graphics driver
        return 3
    fi

    # dirty: it justs checks the leading part, the display part is ignored
    if [[ $cmd == "$x_daemon $x_daemon_args"* ]]; then
        echo "$pid"
        # gets the display number from the process path. Observations: :1-wtf,
        # :wtf are allowed display names too. Let's just assume that everyone
        # uses sane display numbers (:1). Additional note: the display number
        # in the conffile may change during startup and shutdown
        local display=":${cmd##* :}"
        display="${display%% *}"

        if ! xdpyinfo -display "$display" &>/dev/null; then
            # X is not ready or you're not allowed to connect to it
            return 5
        fi

        return 0
    fi

    # it's another X instance
    if [[ $cmd == "$x_daemon"* ]]; then
        # not a bumblebee X server
        return 4
    fi

    # not a X server at all
    return 2
}

# sets the graphics driver for the script and load related settings
set_graphics_driver() {
    DRIVER="$1"

    # The library path in which the X server can find libraries like GL
    X_LD_LIBRARY_PATH=
    X_LD_LIB32_PATH=
    X_LD_LIB64_PATH=

    # allow to set X_LD_LIBRARY_PATH if needed
    if [ -s "${BUMBLEBEE_LIBDIR}/drivers/${DRIVER}.options" ]; then
        . "${BUMBLEBEE_LIBDIR}/drivers/${DRIVER}.options"
        if $IS_64; then
            [ -n "$X_LD_LIB64_PATH" ] && X_LD_LIBRARY_PATH="$X_LD_LIB64_PATH"
        else
            [ -n "$X_LD_LIB32_PATH" ] && X_LD_LIBRARY_PATH="$X_LD_LIB32_PATH"
        fi
    fi
}

# load the settings and sets some other variables
load_settings() {
    # defaults
    STOP_SERVICE_ON_EXIT=N
    VGL_DISPLAY=:8
    VGL_COMPRESS=proxy
    ECO_MODE=N
    FALLBACK_START=N
    DRIVER=nvidia
    X_CONFFILE=
    BUMBLEBEE_GROUP=bumblebee
    BUMBLEBEE_LOGFILE=/var/log/bumblebee.log
    . "$BUMBLEBEE_CONFDIR/bumblebee.conf"

    # allow the user to specify a custom xorg path, otherwise base on driver
    [ -z "$X_CONFFILE" ] && X_CONFFILE="$BUMBLEBEE_CONFDIR/xorg.conf.${DRIVER}"

    # -config file   use a certain xorg.conf so the nvidia drivers can be used
    # -sharevts      without this option, the current VTY running X becomes
    #                blank while the Bumblebee X server is running
    # -nolisten tcp  do not use start a TCP server listening for connections
    # -noreset       do not logout after the last program closes
    X_DAEMON_ARGS="-config $X_CONFFILE -sharevts -nolisten tcp -noreset"

    set_graphics_driver "$DRIVER"

    # Remove colon and everything before it: :1.0 -> 1.0
    DISPLAY_NUMBER=${VGL_DISPLAY##*:}
    # Remove dot and everything after it: 1.0 -> 1
    DISPLAY_NUMBER=${DISPLAY_NUMBER%%.*}
    PIDFILE="/tmp/.X${DISPLAY_NUMBER}-lock"
    X_LOGFILE="/var/log/Xorg.${DISPLAY_NUMBER}.log"

}
